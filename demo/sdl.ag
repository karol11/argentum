using sys { String }

const xEventQuit = 256;
const xRendererAccelerated = 2;
const xImgJpg = 1;
const xImgPng = 2;
const xInitEverything = 0x7231;
const xDefaultPos = 0x1FFF0000;

class Rect{
   x = 0;
   y = 0;
   w = 0;
   h = 0;
   xywh(vx int, vy int, vw int, vh int) this {
      x := vx;
      y := vy;
      w := vw;
      h := vh
   }
   ltrb(l int, t int, r int, b int) this {
      x := l;
      y := t;
      w := r - l;
      h := b - t
   }
   cwh(cx int, cy int, vw int, vh int) this {
      x := cx - vw / 2;
      y := cy - vh / 2;
      w := vw;
      h := vh
   }
   cx() int { x + w / 2 }
   cy() int { y + h / 2 }
   left() int { x }
   top() int { y }
   right() int { x + w }
   bottom() int { y + h }
}

class Sdl {
    internalEvent Blob;

    init(sdlFlags int, sdlImageFlags int) bool;
    pollEvent() ?Event;
}
fn disposeSdl(sdl Sdl);

class Window {
    internalWndHandle = 0;
    internalRendererHandle = 0;
    init(title -String, bounds -Rect, wndFlags int, rendFlags int) bool;
    fill(color int);
    fillRectXYWH(x int, y int, w int, h int, color int);
    fillRect(r -Rect, color int);
    bltXYWH(tex Texture, sx int, sy int, sw int, sh int, dx int, dy int, dw int, dh int);
    blt(tex Texture, src -Rect, dst -Rect);
    flip();
}
fn destroyWindow(w Window);
fn afterCopyWindow(w Window) { w.handle := w.renderer := 0 }

class Event {
    +sys_Blob;
    getAt(i int) int { get32At(i) }
}

class Texture{
    id = 0;
    w = 0;
    h = 0;
    load(wnd Window, fileName -String);
    setAlphaMod(multiplier int) {
        id != 0 ? sdlFfi_setTextureAlphaMod(id, multiplier);
    }
    setColorMod(color int) {
        id != 0 ? sdlFfi_setTextureColorMod(id, color);
    }
}
fn disposeTexture(t Texture);
fn afterCopyTexture(t Texture) { t.id := 0 }

class Font{
    id = 0;

    load(fontName -String, style int) bool;

    name() String;
    style() String;
    stylesCount() int;

    // Create bitmap image of a string
    // flags - italic, bold, underline
    renderTo(res Texture, s -String, ptSize int, flags int, w Window);
    render(s -String, w Window, ptSize int, flags int) @Texture {
        res = Texture;
        renderTo(s, ptSize, flags, res);
        res
    }

    // Measure how many characters fits in width.
    fit(s -String, ptSize int, flags int, width int) int;

    // Get the font metrics of the string.
    // Extents Rect filled with metrics of string portion that fits:
    // r.x = -startBearingX
    // r.y = -ascent
    // r.w = endBearingX - startBearingX
    // r.h = ascent + descent
    // So to align multiple text on base line Y, they should be rendered at Y + extent.y.
    // Max height of line of different fonts is max(extent.h).
    // Horisontal step between adjuscent text spans A and B of the same line is result of measure.
    // Safe left margin to fit all pixels of all lines is min(extent.x) and it's usually negative.
    // Safe right margin of all lines = max(lineLastBasePoint+lastExtent.x+lastExtent.width)
    // Safe top margin of the first line = min(baselinePosY + extent.y)
    // SafeBotton margin = max(baseline + extent.y + extent.h)
    // Line width for alignments (center, right) should be measused as sum(results of measure)
    // Returns horisontsl step of base point.
    measure(s -String, ptSize int, flags int, extents Rect) int;
}
fn disposeFont(f Font);
fn afterCopyFont(f Font) { f.id := 0 }
